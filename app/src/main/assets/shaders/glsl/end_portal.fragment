// __multiversion__
// This signals the loading code to prepend either #version 100 or #version 300 es as apropriate.

// To use centroid sampling we need to have version 300 es shaders, which requires changing:
// attribute to in
// varying to out when in vertex shaders or in when in fragment shaders
// defining an out vec4 FragColor and replacing uses of gl_FragColor with FragColor
// texture2D to texture
#if __VERSION__ >= 300

	// version 300 code

	#ifdef MSAA_FRAMEBUFFER_ENABLED
		#define _centroid centroid
	#else
		#define _centroid
	#endif

	#ifndef BYPASS_PIXEL_SHADER
		#if defined(TEXEL_AA) && defined(TEXEL_AA_FEATURE)
			_centroid in highp vec2 colorLookupUV;
		#else
			_centroid in vec2 colorLookupUV;
		#endif
	#endif

	#define varying in
	#define texture2D texture
	out vec4 FragColor;
	#define gl_FragColor FragColor
#else

	// version 100 code

	#ifndef BYPASS_PIXEL_SHADER
		varying vec2 colorLookupUV;
	#endif
#endif


#ifndef BYPASS_PIXEL_SHADER
	varying vec4 color;
	varying POS4 encodedPlane;
	varying POS3 eyePositionInWorld;
	varying POS3 surfacePositionInWorld;

	#ifdef FOG
		varying vec4 fogColor;
	#endif
#endif

uniform sampler2D TEXTURE_0;
uniform sampler2D TEXTURE_1;

uniform float TIME;

const float MAX_LAYER_DEPTH = 32.0;

void main()
{
	#ifdef BYPASS_PIXEL_SHADER
		gl_FragColor = vec4(0, 0, 0, 0);
	#else

		///// Decode Input Values
		// Decode parallax plane data
		vec3 planeNormal = normalize((encodedPlane.xyz - vec3(0.5,0.5,0.5)) * 2.0);
		float planeDistance = encodedPlane.w * MAX_LAYER_DEPTH;
		// Calculate view direction from the surface position and the eye position
		POS3 viewDirection = normalize(surfacePositionInWorld - eyePositionInWorld);
		// Find any point on the parallax plane, some distance from the actual surface
		POS3 parallaxPlaneOrigin = surfacePositionInWorld.xyz - (planeDistance * planeNormal);
		
		///// Ray-cast for parallax-offset UV
		// Perform ray-plane intersection to find the position on the parallax plane
		highp float t = (dot(parallaxPlaneOrigin - eyePositionInWorld, planeNormal)) / dot(viewDirection, planeNormal);
		POS3 parallaxSurfacePosition = eyePositionInWorld + (t * viewDirection);

		///// Ridiculous UV-remapping
		highp vec2 possibleUVResults[3];
		possibleUVResults[0] = parallaxSurfacePosition.yz;
		possibleUVResults[1] = parallaxSurfacePosition.xz;
		possibleUVResults[2] = parallaxSurfacePosition.xy;
		vec3 absNormal = floor(abs(planeNormal) + vec3(0.5,0.5,0.5));
		// Since all normals are orthonormal on <x,y,z>, mask out the correct uv result
		highp vec2 raycastUV = possibleUVResults[0] * absNormal[0] + possibleUVResults[1] * absNormal[1] + possibleUVResults[2] * absNormal[2];
		// Scale the UVs to Minecraft pixel size
		raycastUV /= 16.0;

		///// Color Lookup
		vec4 colorSample = texture2D(TEXTURE_1, colorLookupUV);

		///// UV Scrolling
		mediump float scaledTime = TIME / 256.0;
		// Scroll direction based on a value unique to the layer (derived from color)
		mediump vec2 scrollDirection = normalize(vec2(colorSample.g - colorSample.b, colorSample.r - (colorSample.g - colorSample.b)));
		mediump mat2 rot = mat2(vec2(scrollDirection.x, scrollDirection.y), vec2(-scrollDirection.y, scrollDirection.x));
		mediump vec2 resultUV = rot * raycastUV;
		// Offset rotation based on a value unique to the layer (still derived from color)
		resultUV += scrollDirection * dot(colorSample, colorSample) * 128.0;
		resultUV.y += scaledTime;

		///// Color assembly
		vec4 textureSample = texture2D(TEXTURE_0, resultUV);
		float brightness = 1.0 - (encodedPlane.w);
		vec3 result = textureSample.rgb * colorSample.rgb * color.rgb * brightness;

		// Look for hard-coded value to clear the portal first
		
if(planeDistance > MAX_LAYER_DEPTH - 1.0) {
			gl_FragColor = vec4(0.10, 0.14, 0.16, 0.10);
		}
		else {
			gl_FragColor = vec4(result, 1);
}

	#endif
}
